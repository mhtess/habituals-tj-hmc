var binWidth = 0.5
var minBin = -1
var maxBin = 9

var priorBins = _.range(minBin, maxBin,binWidth)


var nearestPriorBin = function(x, bins){
  return x > _.max(bins) ? 
      _.max(bins) :
      x < _.min(bins) ? 
      _.min(bins) :
      bins[Math.round(((x - _.min(bins))/(_.max(bins) - _.min(bins)))*(bins.length-1))]
}

var shape_alpha = function(g,d){return g * d}
var shape_beta = function(g,d){return (1-g) * d}

var marginalizeERP = function(myERP, label){
    Enumerate(function(){
        var x = sample(myERP)
        return x[label]
    })
}

var avoidEnds = function(response){
    return response==0 ? 0.001 : response==1 ? 0.999 : response
}

var gaussianPMF = function(mu, sigma, bins){
  return map(function(b){return Math.exp(gaussianERP.score([mu, sigma], b))}, bins)
}

var discretizeLogNormalPrior = function(e, mu, sigma){
  Enumerate(function(){
    return flip(e) ? priorBins[discrete(gaussianPMF(mu, sigma, priorBins))] : minBin
  })
}

var discretizeLogNormalPrior2 = function(v, bins){
  var e = v[0]
  var mu = v[1]
  var sigma = v[2]
  Enumerate(function(){
    return flip(e) ? bins[discrete(gaussianPMF(mu, sigma, bins))] : minBin
  })
}

var mix2GaussiansWithDelta = function(mix, e1, e2,m1, s1, m2, s2, bins){
  Enumerate(function(){
    return flip(mix) ? 
            flip(e1) ? bins[discrete(gaussianPMF(m1, s1, bins))] : minBin :
            flip(e2) ? bins[discrete(gaussianPMF(m2, s2, bins))] : minBin
  })
}



var HDI = function(samples, credMass){
  var sortedPts = samples.sort()
  var ciIdxInc = Math.ceil(credMass* sortedPts.length)
  var nCIs = sortedPts.length - ciIdxInc
  var ciWidth = map(function(i){
    sortedPts[i + ciIdxInc] - sortedPts[i]
  },_.range(nCIs))
  var i = _.indexOf(ciWidth, _.min(ciWidth))
  return [sortedPts[i], sortedPts[i+ciIdxInc]]
}

var reasonableDiscretization = function(v){
  var e = v[0]
  var mu = v[1]
  var sigma = v[2]
  var ci = HDI(repeat(10000, function(){return gaussian(mu,sigma)}), 0.95)
  var binWidth = (ci[1]-ci[0])/10
  var bins = _.range(ci[0], ci[1], binWidth);
  var finalState =(_.max(bins) > maxBin) ? _.max(bins) : maxBin;
  var stateBins = _.union(bins,[finalState])
  var finalTheta = (_.max(bins) > maxBin) ? 
                      _.max(bins) - binWidth/2 : 
                      maxBin - ((maxBin - _.max(bins)) / 2)
  var thetaBins = _.union(map(function(x) {
    return x + binWidth/2;
  }, bins), [finalTheta]);
  return {stateBins: stateBins, thetaBins: thetaBins}
}


var guessingLink = function(myERP, phi){
    Enumerate(function(){
        var x = flip(1-phi) ? 
                    sample(myERP) :
                    ["habitual","mm"][discrete([0.5,0.5])]
        return x
    })
}

var softmaxERP = function(speakerERP, softmax){
  Enumerate(function(){
      var supp = speakerERP.support()
      var probs = map(function(s){return Math.exp(softmax*speakerERP.score([],s))}, supp)
      var response = supp[discrete(probs)]
      return response
  })
}

var normalize = function(probs){
    return map(function(x){return x/sum(probs)}, probs)
}
